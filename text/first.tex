% -*- mode: LaTeX; mode: auto-fill; mode: flyspell; coding: koi8-r; -*-
\chapter{Управление памятью.}

Управление памятью состоит из двух основных задач: Выделение памяти и
восстановление или очистка памяти. Существует несколько подходов к выделению
памяти.

\section{Статическое выделение памяти.}

Самым простым подходом является статическое выделение памяти. Если система
использует только эту политику, это значит что адреса для хранения всех данных
определяются во время компиляции. Во время исполнения области данных уже не
изменяются и освобождаются только при завершении программы. Кроме того если
система использует только эту политику, то локальные переменные при вызове
функции ссылаются на одну и ту же область при каждом вызове. Статическое
выделение памяти являлось стандартной политикой в языке
Fortran~\cite{ANSI:1966:ANS}. Этот подход имеет три серьёзных ограничения:
\begin{itemize}
\item Размеры всех структур данных должны быть известны во время компиляции.
\item Невозможно создание рекурсивных процедур, поскольку локальные переменные
  при рекурсивном вызове будут затираться.
\item Структуры данных не могут быть созданы динамически.
\end{itemize}
Несмотря на это у такой политики существуют и плюсы. Языки использующее
статическое выделение памяти как правило быстры, поскольку нет нужды создавать
или удалять структуры данных во время работы программы. Так как все адреса
данных известны во время компиляции,%
% 1 
то обращение к данным всегда может быть прямым, а не косвенным. Кроме того
статическое выделение памяти гарантирует, что программа не может свалиться во
время работы из-за попытки выделить память больше чем существует в системе, так
как все требования к памяти известны заранее.

\section{Выделение памяти на стеке.}

Другая политика управления памятью начала активно использоваться с появлением
блочных языков программирования~\cite{GCJones}~\cite{branquart:a}. Блочные языки
программирования преодолели некоторые ограничения статического выделения памяти
при помощи выделения памяти на стеке. Активационные записи функций, или фреймы,
создавались на вершине стека при вызове каждой подпрограммы. Организация памяти
на стеке имела следующие следствия:
\begin{itemize}
\item Различные вызовы одной и той же процедуры не разделяли локальные
  переменные. Таким образом появлялась возможность создавать рекурсивные
  процедуры и увеличивалась выразительная способность языков.
\item Размер локальных данных мог изменяться в зависимости от значения
  аргументов.
\item Значения локальных переменных не могли быть сохранены между вызовами.
\item Активационная запись вызванной функции не могла жить дольше чем запись
  функции её вызвавшей.
\item Только объекты чей размер был известен во время компиляции могли быть
  возвращены как результат работы процедуры.
\end{itemize}
Порядок освобождения памяти, выделенной на стеке, определялся в момент
компиляции и соответствовал блочной структуре кода.
% 2 

\section{Выделение памяти в куче.}

Третей политикой выделения памяти было выделение памяти в куче. Куча позволяет
выделять у уничтожать объекты в произвольном порядке. Таким образом
активационные записи и динамически создаваемые структуры данных могут иметь
время жизни больше, чем процедура их создавшая. Выделение памяти в куче имеет
ряд преимуществ:
\begin{itemize}
\item Многие задачи реального мира проще всего представляются через
  иерархические структуры данных, такие как деревья или списки. Выделение памяти
  в куче позволяет создавать рекурсивные реализации этих абстракций.
\item Размер структур данных не обязан быть фиксированным и может определяться
  во время исполнения.
\item Объекты переменного размера могут быть возвращены в качестве результата
  работу процедуры
\item Многие современные языки программирования позволяют возвращать процедуры
  как результат работы других процедур. Языки использующие выделение памяти на
  стеке могут это делать, если в них запрещены вложенные процедуры: в качестве
  возвращаемого значения используется статический адрес возвращаемой
  процедуры. Функциональные и высокоуровневые императивные языки, кроме того,
  позволяют возвращать приостановленные функции или замыкания: функцию вместе с
  её окружением, в котором указаны значения переменных. Эти значения, таким
  образом, должны существовать дольше чем функция, которая их создала.
\end{itemize}                   %
% 3 
Как правило при выделении памяти в куче неизвестно как долго будет существовать
тот или иной объект, по этому возникает проблема управления восстановлением
памяти.

\section{Выделение памяти в регионах.}

И последней предложенной политикой было выделение памяти на
регионах~\cite{SPE:SPE4380200104}. Регионы --- это кучи, в которых можно
выделять память под объект и которые можно уничтожать целиком. Создание и
уничтожение регионов, как правило~\cite{Tofte04aretrospective}, происходит на
стеке в соответствии с блочной структурой языка. Это позволяет получить все те
же преимущества, что и выделение памяти в куче, а также, дополнительно,
предоставляет простой порядок восстановления выделенной памяти. Из недостатков
этого подхода можно отметить более сложную, чем для кучи или стека, организацию
памяти, которая требует накладных расходов, а также требует возможности
существования региона, в котором выделено очень много памяти, долгое
время. Память таким образом может быть долго занята уже не используемыми
объектами. Эта проблема, как правило, решается также как и в случае
использования одной кучи.

\section{Восстановление памяти.}

При выделении памяти на куче, благодаря тому что объекты могут жить намного
дольше чем создавшие их процедуры, появляется проблема восстановления
памяти. Действительно глядя на структуру программы невозможно определить в какой
момент память выделенную под тот или иной объект можно будет восстановить и
использовать повторно. Для решения этой проблемы был создан ряд техник.
% 4 

\subsection{Ручное управление памятью.}

В случае ручного управления памятью для создания объекта программист вручную
вызывает команду выделения памяти. Эта команда возвращает указатель на
выделенную область памяти. Данный указатель сохраняется и используется для
доступа к объекту для которого память была выделена. Когда надобность в объекте
проходит, программист явно вызывает команду освобождения памяти.

В случае использования ручного управления памяти усложняется проектирование
программ, поскольку для каждого объекта необходимо явно определять условия при
которых он должен быть уничтожен и реализовывать код для проверки этих
условий. Кроме того существуют две проблемы, которые возможны в любом языке
позволяющем ручное управление памятью:
\begin{itemize}
\item \bf{Висячие ссылки}. \\
  Висячие ссылки --- это оставшиеся в использовании ссылки на объект которого
  больше не существует. Память, на которую указывает такая ссылка, может быть
  отдана операционной системе и быть недоступной или быть выделена под другой
  объект. В первом случае попытка обращения по такой ссылке приведёт к
  аварийному завершению программы. Во втором случае поведение программы может
  быть непредсказуемым. Так считанные данные могут представлять невозможное
  состояние для ожидаемого объекта, а попытка записи уничтожит чужие данные
  создавая новые проблемы в работе программы. Как правило висячие ссылки
  появляются из-за неправильной оценки программистом времени жизни объекта, так
  что память выделенная под него восстанавливается раньше, чем использование
  объекта действительно прекратится. Вот пример на языке C демонстрирующий
  появление такой ссылки:%
% 5 

\begin{code}
char *var = malloc (length);
free (var);
var[length-4] = 0;
\end{code}\sloppy

\item \bf{Утечки памяти}.\\
  Утечками памяти называют такие объекты, на которые не осталось программно
  доступных ссылок, но при этом память, выделенная под объект, не была
  восстановлена. Если объекты, ссылки на которые теряются, создаются в программе
  постоянно, утечка памяти проявляется в постоянном увеличении объема занятой
  памяти, что существенно уменьшает скорость работы за счёт необходимости
  использования операционной системой свопа, при недостатки оперативной
  памяти. Кроме того утечки памяти могут исчерпать всю доступную память и
  вызвать экстренное завершение программы. Простым примером утечки памяти может
  служить следующий код на \verb=C=:

  \begin{code}
int **matrix = calloc (size, sizeof (int *));
for (i=0; i<size; i++) {
  matrix[i] = calloc (size, sizeof (int));
}
free (matrix);
  \end{code}

  При выполнении этого кода память выделяется и для списка указателей, строк
  матрицы, и для самих строк. При очистке же удаляется только память выделенная
  под список указателей. При этом теряются адреса по которым размещены строки
  матрицы. Таким образом эти строки невозможно ни использовать, ни удалить.
\end{itemize}
\sloppy

Для упрощения ручного управления памятью используются умные
указатели~\cite{ISO:2012:III}, то есть указатели обладающие некоторой
дополнительной функциональностью. Примерами умных указателей являются простые
владеющие указатели и указатели с подсчётом ссылок.
\begin{itemize}
\item Простые владеющие указатели при изменении ссылки автоматически вызывают
  функцию удаления объекта на который они ссылались раньше. Это создаёт
  трудности с передачей ссылок вне контекста в котором они были созданы.
% 6 
\item Указатели с подсчётом ссылок предоставляют специальные операции ``увеличить
  количество ссылок'' и ``уменьшить количество ссылок''. Если в результате
  уменьшения количество ссылок стало равным нулю, то вызывается код уничтожения
  объекта. 
\end{itemize}

Также для диагностики проблем связанных с некорректной работой с памятью
существует множество дополнительных программ:
\begin{itemize}
\item Программы профилировщики памяти могут определять сколько было выделено и
  освобождено памяти в тот или иной момент работы программы.
\item Статические анализаторы могут определять может ли код привести к
  ошибкам. В том числе и к ошибкам работы с памятью.
\item Также существуют библиотеки которые помогают следить за выделением и
  освобождением памяти во время работы программы. Эти библиотеки подменяют собой
  функции выделения и восстановления памяти и проводят детальный анализ каждого
  вызова. Таким образом запуская программу множество раз можно попытаться
  обнаружить ошибки работы с памятью.
\end{itemize}

Но в действительности все эти методы не позволяют полностью избавиться от утечек
памяти, так что чаще всего в современных языках программирования применяются
методы основанные на сборке мусора.

\subsection{Сборка мусора.}

Самым распространённым на сегодняшний день подходом к восстановлению памяти
является сборка мусора. При использовании этого подхода программисту %
% 7 
предоставляются лишь команды выделения памяти, а за освобождением система следит
самостоятельно. К сборке мусора существует три основных подхода: подсчёт ссылок,
алгоритм пометок и копирующая сборка.

\subsubsection{Подсчёт ссылок.}
Сборка мусора основанная на методе подсчёта ссылок работает аналогично умным
указателям с подсчётом ссылок с той лишь разницей, что у программиста нет явного
доступа к операциям увеличения и уменьшения количества ссылок. При корректной
реализации подсчёта ссылок время жизни объекта равно времени в течении которого
этот объект доступен для обращения из программы. Главной проблемой данного
подхода является невозможность удалить те объекты, между которыми существуют
циклические ссылки, поскольку в таком случае счётчик ссылок на объект никогда не
станет равным нулю. Кроме того использование подсчёта ссылок требует от языка
неявного создания поля, содержащего количество ссылок на объект, для каждого
объекта. Наличие такого поля может существенно увеличивать расход памяти. Также
возможна проблема с переполнением счётчика ссылок. Обработка переполнения
счётчика ссылок требует дополнительного кода и может создавать объекты, которые
никогда не будут удалены.

\subsubsection{Алгоритм пометок.}
Другим подходом является сборка мусора основанная на алгоритме пометок. Для
работы этого алгоритма выделяются корневые объекты --- объекты которые
гарантированно достижимы во время запуска сборки мусора. Кроме того каждый
объект содержит один бит указывающий на то, является ли объект достижимым.
\begin{enumerate}
\item При вызове сборки мусора все объекты, кроме корневых, помечаются как
  недостижимые. 
% 8 
\item Рекурсивно просматриваются и помечаются как достижимые все ещё не
  помеченные объекты до которых можно добраться из помеченных.
\item После завершения просмотра те объекты, у которых бит достижимости остался
  равным 0, считаются недостижимыми и удаляются.
\end{enumerate}
Этот алгоритм позволяет уничтожать циклические ссылки и имеет меньшие
дополнительные расходы по памяти, чем подсчёт ссылок. Но он также вносит ряд
дополнительных ограничений. Для того, чтобы гарантировать, что этот алгоритм
соберёт все недостижимые объекты, язык должен предоставлять средства для
определения какие из полей объекта являются ссылками. В действительности
возможна ``консервативная'' реализация модификации этого алгоритма, которая
считает ссылками все поля~\cite{Boehm:1988:GCU}. В таком случае недостижимыми
помечаются только часть недостижимых объектов. Таким образом работает Boehm GC.

Другой проблемой данного метода является необходимость просмотра всей выделенной
памяти при вызове сборки мусора, что требует достаточно много временных
затрат. Из-за этого чаще всего сборка мусора вызывается только тогда, когда
память уже заполнена. Кроме того необходимость просматривать каждый объект может
вызывать постоянную работу операционной системы со свопом, для получения доступа
к объектам не поместившимся в памяти.

Для данного метода существует ряд модификаций улучшающих скорость работы. Так,
например, долгоживущие объекты обычно удаляются реже, чем недавно созданные,
благодаря чему при первом проходе можно искать недостижимые объекты только среди
недавно созданных объектов. Также существуют вариации уменьшающие время работы
сборщика мусора за счёт более тесного взаимодействия с
программой~\cite{Dijkstra:1978:OGC}.

% 9 
\subsubsection{Копирующая сборка мусора.}
Для реализации копирующей сборки мусора, также как и для алгоритма пометок,
требуется выделение корневых объектов. Для работы этого алгоритма память
разделяется на две части ``старое пространство'' и ``новое пространство''. Также
требуется бит, указывающий на то был ли этот объект уже скопирован.
\begin{enumerate}
\item При вызове сборки мусора корневые объекты копируются в ``новое
  пространство'', а в ``старом пространстве'' у них устанавливается бит что они
  были скопированы. У всех остальных объектов бит устанавливается равным 0.
\item Рекурсивно просматриваются все ссылки из объектов расположенных в ``новом
  пространстве'', которые указывают в ``старое пространство''. Если у объекта по
  ссылке установлен бит того, что объект был скопирован, то в просматриваемом
  объекте из ``нового пространства'' обновляется ссылка на объект. В противном
  случае найденный объект копируется из ``старого пространства'' в новое, после
  чего ссылка в рассматриваемом объекте также обновляется.
\item Удалить все объекты из ``старого пространства'' и поменять пространства
  ролями.
\end{enumerate}
После первых двух шагов все достижимые объекты скопированы в ``новое
пространство'' и ссылки между ними обновлены, так что ``старое пространство''
можно спокойно отмечать как свободное.

Для копирующей сборки мусора необходимо иметь возможность точно определить все
ссылки на объекты, поскольку все они должны быть обновлены. Таким образом
невозможна ``консервативная'' реализация этого алгоритма. Кроме того для работы
алгоритма необходимо оставлять половину памяти свободной, чтобы было достаточно %
% 10 
места для хранения копий всех активных объектов.

К плюсам данного метода можно отнести упрощение соответствующего метода
выделения памяти. Поскольку в результате работы сборщика память сжимается, то
свободная часть памяти является неразрывной и выделять её можно просто в начале
блока. Кроме того стоимость сборки пропорциональна не количеству объектов, а
количеству достижимых объектов.

Среди модификаций данного метода есть такие, которые разделяют память на
небольшие блоки, для уменьшения дополнительной памяти для сборки мусора в каждом
из блоков~\cite{Ungar:1984:GSN}. Также существуют инкрементальные реализации
алгоритма, которые вызывают алгоритм при наборе определённых событий и, за счёт
этого, уменьшают общее время сборки мусора~\cite{Lieberman:1983:RGC}.

\subsubsection{Проблемы сборки мусора.}
Последние два описанных метода сборки мусора имеют ряд общих проблем.
\begin{itemize}
\item Из-за необходимости остановки вычислений становится очень сложной их
  адаптация к системам реального времени.
\item Так как сборка мусора вызывается не после каждой модификации памяти, то
  существует время, и зачастую достаточно большое, между моментом когда объект
  становится недоступным и временем, когда занятая им память возвращается
  система.
\item Скорость работы программы может очень сильно варьироваться от того
  запущены ли на компьютере другие программы, объёма физической памяти и
  настроек, связанных с моментом вызова сборки мусора.
\item Данные методы усложняют оценку минимально необходимой памяти для работы
  программы. 
\end{itemize}                   %
% 11 
Кроме того все методы сборки мусора уменьшают способность программиста
предсказать в после какого конкретно момент память, выделенная под его данные,
будет восстановлена.
% 12 