% -*- mode: LaTeX; mode: auto-fill; mode: flyspell; coding: koi8-r; -*-
% 39 
\chapter{Прототип языка использующего стек очередей.}

На основе рассуждений представленный выше можно построить язык работающий на
основе стека очередей. Для минимального C-подобного языка потребуется следующий
набор специальных форм:
\begin{itemize}
\item \verb=for(N1, N2, pre_cycle, condition, post_steps, [Body])=\\
  Для создания циклических конструкций. Для тела цикла создаётся две
  очереди. Очередь N1 работа с которой происходит автоматически и очередь N2
  которая создаётся в начале каждой итерации и удаляется в конце. Очередь N2
  доступна для ручного управления.
\item \verb=if(N, condition, [Then], [Else])=\\
  Для создания ветвлений. Очередь созданная для блока будет иметь имя N.
\item \verb=block(N, [Body])=\\
  Для создания вложенных блоков. Очередь созданная для блока будет иметь имя N.
\item \verb=enqueue(N)=\\
  Создаёт на очереди N метку. 
\item \verb=dequeue(N)=\\
  Удаляет все объекты находящиеся в очереди между началом очереди и последней
  меткой. Если метка не обнаружена, то удаляет все объекты на цикле.
\item \verb=function(Name, N, Queues, Arguments, [Body])=\\
  Определяет новую функцию с именем Name, которая может создавать объекты на
  очередей из Queues. Цикл связанный с верхним блоком кода именуется N.
\item \verb=call(Name, Queues, Arguments)=\\
  Вызывает функцию с именем Name, передав в качестве аргументов соответствующие
  очереди и аргументы.
\end{itemize}
% 40 
Неявно считается, что первой командой в начале каждого блока с именем N
выполняется \verb=enqueue(N)=, а последней \verb=dequeue(N)=. 

Кроме того можно ввести следующий набор правил:
\begin{itemize}
\item Внутри тела цикла \verb=for= не может находится инструкций \verb=dequeue=
  для внешних, по отношению к циклу, очередей.
\item \verb=dequeue(N)= можно вызывать только для очередей определённых в
  лексической области видимости.
\item Если в одной из ветвей блока \verb=if= есть инструкция
  \verb=dequeue(N)=, где \verb=N= это имя очереди определено во внешнем,
  относительно \verb=if= блоке, то во второй ветви должна быть аналогичная
  инструкция. 
\end{itemize}

Кроме того требуется более подробное описание как исполняется цикл. Конструкция
\verb=for(N1, N2, pre, test, post, [Body])= должна исполняться следующим
образом:

\begin{code}
block(N1, [
  pre,
  test,
  block(N2, [Body]),
  enqueue(N1),
  post,

  test,
  dequeue(N1),
  block(N2, [Body]),
  enqueue(N1),
  post,

  % повторяется пока условия не станет ложным.

  test,
  dequeue(N1),
  block(N2, [Body]),
  enqueue(N1),
  post,

  test,
  dequeue(N1),
])  
\end{code}
% 41 

Также в языке нужен минимальный набор функций:
\begin{itemize}
\item \verb=new(N, X, Value)=\\
  Выделяет память на конце очереди N, сохраняет в ней значение Value и
  записывает адрес в X.
\item \verb=set(X, Value)=\\
  Берёт адрес X и меняет значение переменной на Value.
\item \verb=sum(X, Y, R)=\\
  Берет значение по адресу X, прибавляет значение по адресу Y и записывает
  значение по адресу R.
\item \verb=sub(X, Y, R)=\\
  Берет значение по адресу X, вычитает значение по адресу Y и записывает
  значение по адресу R.
\item \verb=mul(X, Y, R)=\\
  Берет значение по адресу X, умножает на значение по адресу Y и записывает
  значение по адресу R.
\item \verb=div(X, Y, R)=\\
  Берет значение по адресу X, делит на значение по адресу Y и записывает
  значение по адресу R.
\item \verb=pass=\\
  Данная операция ничего не делает.
\item \verb=print(X)=\\
  Вывести на экран значение X.
\item \verb=change(X, Value)=\\
  Переменная с именем X попадает в конец очереди. Это действие добавлено для
  простоты реализации прототипа на языке Prolog:

  \begin{code}
block(N, [
  new(N, X, 42),
  enqueue(N),
  new(N, Y, 12),
  change(X, 42),
  dequeue(N)
])
  \end{code}
  В данном коде после выполнения прологом команды \verb=new(N, X, 42)=
  переменная X связывается с конкретным значением. Чтобы в реализации можно было
  использовать не инициализированные переменные из языка Prolog, а не
  реализовывать окружения на разрешении имён атомов, добавлена эта операция.
\end{itemize}

Давайте рассмотрим пример кода в предложенном языке:

\begin{code}
function(fact, N, [RQueue], [V, Result],
[ new(N, R, 1),
  for(N1, N2,
      [ new(N1, A, V)
      ],
      A,
      [ change(A, A),	
	sub(A, 1, A)
      ],
      [ new(N2, Temp, 0),
	mul(A, R, Temp),
	set(R, Temp)
      ]
     ),
  new(RQueue, Result, R)
]).

function(main, M, [], [],
[ new(M, V, 10),
  enqueue(M),
  call(fact, [M], [V, Result]),
  dequeue(M),
  print(Result)
]).
\end{code}

Функция main работает следующим образом:
\begin{enumerate}
\item Создаёт переменную V на очереди M и устанавливает её равной 10.
\item Добавляет метку на очередь.
\item Вызывает функцию fact, которая создаст результат на очереди M и вернёт
  ссылку в Result
\item Удаляет все переменные созданные до метки. Таким образом V удаляется из
  памяти.
\item Выводит значение результата.
\end{enumerate}
Функция fact содержит следующий код:
\begin{enumerate}
\item Создаёт переменную R в которой будет накапливаться результат в очереди N.
\item Запускает цикл. Перед началом цикла создаёт переменную A равную аргументу
  функции.
\item На каждом шаге пока A не равно нулю
  \begin{enumerate}
  \item Создаёт временную переменную Temp.
  \item Записывает в Temp результат умножения A на R.
  \item Устанавливает значение R равным Temp.
  \end{enumerate}
\item В конце каждого шага переносит A на конец очереди N1 и уменьшает на 1.
\end{enumerate}
Код fact намеренно усложнён, для демонстрации логики цикла. Код функции main
показывает тривиальный пример управления памятью на очереди.