% -*- mode: LaTeX; mode: auto-fill; mode: flyspell; coding: koi8-r; -*-
% 13 
\chapter{Существующие статические методы.}

Большинство усилий по разработке методов управления памятью были направлены на
улучшение методов сборки мусора работающих во время выполнения. Но, кроме этого,
также было несколько попыток улучшать статические политики, такие как выделение
памяти на регионах, и проводить статические преобразования кода, которые заметно
улучшали работу алгоритмов сборки мусора за счёт обнаружения момента последнего
использования объектов.

\section{Статические методы ассистирования сборке мусора.}

Существующие проблемы со скоростью работы сборщиков мусора и потенциально долгим
временем жизни уже недостижимых объектов спровоцировало разработку набора
методов, которые статически добавляют инструкции освобождения памяти тех
объектов, для которых возможно доказать, что они больше не будут
использоваться.

\subsection{Замена сборки мусора на более подходящие методы.}

Самым распространённым подходом к оптимизации сборки мусора является анализ того
память под какие данные можно выделять статически или на
стеке~\cite{Jones:1976:BTO:800168.811542}\cite{Ruggieri:1988:LAD:73560.73585}\cite{Steele:1978:RCS:889478}.

Так, к примеру, Muchnik и Jones описали~\cite{FAaOoLLS} анализ классифицирующий
объекты по наиболее подходящему для них методу восстановления памяти:
\begin{itemize}
\item Объекты на которые никогда не появляется больше одной ссылки --- Когда
  указатель на такой объект уничтожается, то объект может быть уничтожен. Для
  таких объектов нет нужды применять другие техники.
% 14 
\item Объекты которые никогда не используются в циклических структурах. Эти
  объекты могут быть собраны с использованием подсчёта ссылок.
\item Объекты которые могут встречаться в циклических структурах. Для данных
  объектов использовалась сборка мусора, но при этом дополнительная память
  используемая для подсчёта ссылок на них не тратилась.
\end{itemize}

Обычно на большую часть данных никогда не появляется больше одной
ссылки~\cite{Clark:1977:ESL:359423.359427}, по этому выделение таких объектов в
отдельный класс может существенно сократить потребление памяти и уменьшить время
и частоту вызовов сборщиков мусора.

Кроме того многие языки, такие как C и C\#, предоставляют возможность явно давать
указание о том, выделять память на стеке или в куче.

Данные подходы не предлагали новых политик восстановления памяти, а только
вводили использование разных политик для разных классов данных.

\subsection{Простые модификации программы.}

При использовании сборки мусора серьёзной проблемой является то, что время пока
переменная доступна и время которое она видима часто не совпадают. Так в коде:

\begin{code}
{
  Type1 variable1 = new Type1(args);
  variable1.update(data);
  Type2 variable2 = new Type1(variable1);
  // 100 lines of variable2 processing
  // ...
}
\end{code}\sloppy
% 15 

После получения значения \verb=variable2= переменная \verb=variable1= больше
не используется, но система считает что она достижима до самого конца
блока. Простым способом улучшающим потребление памяти в системе является
добавление инструкции ``\verb|variable1 = null;|'' сразу после последнего
использования переменной. При этом ссылка из локальной области видимости на
объект пропадёт и, если других ссылок не существовало, то при следующем вызове
сборки мусора этот объект гарантированно будет собран. 

Такой подход не может работать в системах без сборки мусора времени выполнения,
поскольку в действительности не реализует операции восстановления памяти.

\subsection{Сборка мусора времени компиляции с использованием подсчёта ссылок.}

Одним из примеров методов для статической сборки мусора является алгоритм
статического анализа, который предложил Хэдерман~\cite{hederman}.

Этот алгоритм основан на идее подсчёта ссылок. В действительности аккуратный
подсчёт ссылок на тот или иной объект можно провести только во время исполнения
программы, поскольку в программах нередко появляются ветвления и циклы, и на
разных путях количество ссылок на один и тот же объект оказывается
различным. Таким образом для работы алгоритма была выбрана более слабая
трактовка количества ссылок на объект: это число больше либо равное настоящему
количеству ссылок, которые будут существовать во время работы.

Считается что переменная ссылается на объект, если хотя бы на каком-то из путей
исполнения переменная может ссылаться на объект. Когда копируется ссылка, то
% 16 
есть одной переменной присваивается значение другой, то количество ссылок
увеличивается для всех переменных, на которые могла ссылаться первая
переменная. Когда переменная уничтожается, то уменьшить количество ссылок на
объект, на который она ссылалась, можно только в том случае, если было известно
однозначно что это за объект. Например если переменная \var{x} содержит ссылку
на одни из объектов \var{\{i,j\}}, а \var{y} ссылается на \var{\{j,k,l\}}, то в
результате операции ``\var{x = y}'' нужно увеличить количество ссылок на объекты
\var{j}, \var{k} и \var{l}, но нельзя уменьшить количество ссылок на объект
\var{i} или на объект \var{j}, поскольку неизвестно на какой из них во время
выполнения действительно уменьшится количество ссылок.

Алгоритм сборки мусора времени компиляции, предложенный Хэдерманом, был описан
для простого случая, в котором отсутствовали вложенные ссылки и вызовы
процедур. В модели языка присутствовали четыре типа операций:
\begin{itemize}
\item \var{x $\leftarrow alloc_i$}\\
  Создать объект в куче по адресу i и создать ссылку на него в регистре \var{x}.
\item \var{x $\leftarrow$ nil}\\
  nil представляет все значения удаление котороых не имеет смысл. Это могут быть
  константы, статические объекты или объекты на которые число ссылок просто
  неизвестно.
\item \var{x $\leftarrow$ y}\\
  Установить значение регистра \var{x} равным значению регистра \var{y}.
\item \var{mem $\leftarrow$ x}\\
  Сохранить значение регистра \var{x} в памяти.
\end{itemize}
Первые три операции ``уничтожают'' значение \var{x} и в результате могут сделать
объект, на который \var{x} ссылался мусором.
% 17 
\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{pic/ifgraphs.jpg}
\caption{Примеры анализа}
\label{fig:img1}
\end{figure}

Теперь если построить граф путей, то можно увидеть идею работы алгоритма. Так на
рисунке \ref{fig:img1} на графике A представлена блоксхема для алгоритма в
котором создаются две переменные, после чего по условию либо меняются местами,
либо не делают ничего, и в конце удаляются. При анализе отмечается, что после
создания количество ссылок на область памяти \var{i} и область памяти \var{j}
равно единице. Если исполнение пойдёт по правому пути, то переменная \var{x}
будет ссылаться на \var{i}, а переменная \var{y} на \var{j}. Если же выполнение
% 18 
пойдёт по левому пути, то переменная \var{x} будет ссылаться на \var{j}, а
переменная \var{y} на \var{i}. При схождении этих путей количество ссылок
берётся максимальным из возможных, а множества возможных значений переменных
объединяются. Таким образом на входе в последний блок можно с уверенностью
сказать, что на \var{i} и на \var{j} существует по одной ссылке, а в каждой из
переменных \var{x} и \var{y} ссылки либо на \var{i}, либо на \var{j}. В
последнем блоке, поскольку нам известно, что существует лишь по одной ссылке на
\var{i} и \var{j} можно сказать, что первое присваивание уничтожит одну из
переменных, а второе вторую.

К сожалению за счёт консервативности если бы была возможность вернуть системе
только одну из двух областей памяти \var{i} или \var{j}, то во время компиляции
невозможно было бы определить какая из них действительно будет возвращена. Это
показано на рисунке \ref{fig:img1} на графике B.

\begin{figure}[H]
\centering
\includegraphics[width=0.4\textwidth]{pic/cyclegraphs.jpg}
\caption{Пример анализа цикла}
\label{fig:img2}
\end{figure}

Более того, если в одну переменную могут складываться ссылки на разные объекты,
как на рисунке \ref{fig:img2}, либо если ссылки создаются в цикле, то метод
Хэдермана уже не может гарантированно найти место в котором объект удаляется.
% 19 

Подобные алгоритмы статического анализа имеют те же слабости: они способны
определить возможно ли удалить объект в какой-либо момент работы программы
только для достаточно простого использования переменных. Но как только со
ссылками начинается разветвлённая работа анализ начинает приводить в никуда. При
этом ``достаточно простым'' использованием является такое использование группы
переменных и областей памяти, в котором на области памяти могут ссылаться только
переменные из группы и переменные могут ссылаться только на области памяти из
группы, и при этом ссылки не копируются между переменными в цикле, а в разных
возможных путях выполнения в одну и ту же переменную не складываются ссылки на
большое число разных областей памяти. И несмотря на то, что такими алгоритмами
можно обнаружить место последнего использования многих объектов, по видимому
невозможно их адаптировать для использования в какой-либо общей политике, на
основе которой можно было бы провести всё вычисление.

\section{Выделение памяти на стеке и в регионах.}

Выделение и восстановление памяти при помощи стека является доминирующей
статической политикой управления памятью, благодаря тому что оно предоставляет
изолированную область памяти для каждого вызова происходящего во время работы
приложения. Таким образом не удивительно, что регионы памяти, которые
поддерживали две операции ``выделить память под объект'' и ``уничтожить весь
регион'' в конце концов стали использоваться в качестве единственного объекта
создаваемого на стеке.
% 20 

\subsection{Выделение памяти на стеке.}

Самой известной техникой выделения и восстановления памяти, управляемой при
помощи синтаксиса языка является выделение памяти на стеке. По видимому, первым
языком с блочной структурой, который реализовывал управление памятью на стеке
был Algol-58 (также известный как International Algebraic
Language)~\cite{Perlis:1958}. Благодаря организации памяти на стеке появилась
возможность при последовательном выполнении программы выделять свою независимую
область памяти для каждой процедуры вызываемой в процессе работы.

\begin{figure}[H]
\centering
\includegraphics{pic/stack.eps}
\caption{Стек}
\label{fig:img3}
\end{figure}

Так на глядя на рисунок \ref{fig:img3} очевидно, что процедура \var{X},
вызванная из процедуры \var{Y} может создавать на стеке произвольное количество
локальных переменных не опасаясь повредить данные созданные процедурой \var{Y}
или \var{Main}.

Подход с использованием стека управляемого структурой языка оказался настолько
удачен, что до последнего времени~\cite{Appel87garbagecollection} все блочные
языки программирования предоставляли такую возможность.

Политика управления памятью на стеке также нашла свою нишу в виде ``стековых''
языков программирования. ``Стековые'' языки, в отличие от ``регистровых'', не
имеют регистров для работы с локальными переменными. Вместо этого используются
% 21 
инструкции которые управляют данными на стеке. Такой язык как Forth нередко
используется в встраиваемых устройствах. Кроме того большинство современных
языков программирования в качестве промежуточного представления программы, либо
в качестве байткода используют стековые языки. Отсутствие регистров позволяет
при анализе этого байткода очень быстро получать Static Single Assignment (далее
SSA) форму программы. SSA форма это основная форма в которой проводится
оптимизация кода и скорость её получения важна для JIT компиляторов, которые
работают во время исполнения программы.

\subsection{Выделение памяти в регионах.}

В программах часто встречаются группы объектов с одинаковым временем жизни, но
со временем, которое превосходит время работы метода создавшего эти
объекты. Одним из примеров такой группы могут служить деревья синтаксического
разбора. Узлы этого дерева создаются при обработке разных частей входящих
данных и, как правило, в разных процедурах. Узлы из дерева не удаляются и срок
их жизни ограничен сроком жизни всего дерева.

Для управления памятью в таких случаях была предложена концепция
региона~\cite{Ross:1967:AFS:363534.363546}\cite{SPE:SPE4380200104}\cite{Ruggieri:1987:DMA:914060},
как отдельного объекта. Современные работы по безопасному управлению памяти при
помощи стека регионов начались как попытка разработать технику, которая была
призвана создать для Standart ML технику, требующую меньше дополнительных
расходов памяти и более предсказуемую, чем стандартные техники сборки мусора.

Одной из первых успешных работ по этой теме стала работа Тофте и Талпина по
разработке безопасного интерфейса для управления памятью в функциональных
языках~\cite{toftetalpin92}\cite{Tofte:1994}.
% 22 

\begin{figure}[H]
\centering
\includegraphics{pic/region.eps}
\caption{Стек регионов. Регионы обозначены прямоугольниками.}
\label{fig:img4}
\end{figure}

В модели основанной на стеке регионов каждое выражение исходного языка
заменялось на соответствующее выражение с явной аннотацией регионов. За
исключением расположения результата в памяти выполнение оставалось эквивалентным
оригинальному. Использовались две формы аннотации:
\begin{itemize}
\item \var{$e_1$ at $\rho$}
\item \var{letregion $\rho$ in $e_2$ end}
\end{itemize}
Первая форма использовалась в случае, когда $e_1$ непосредственно возвращает
результат, независимо от того это значение, замыкание или кортеж значений. Этот
результат складывался в регион $\rho$.

Вторая форма создавала регион с именем $\rho$ с локальной областью видимостью
равной $e_2$. Во время выполнения эта инструкция создавала на вершине стека
новый регион, выполняла все команды из $e_2$ и уничтожала регион. Инструкция
\var{letregion} была единственной инструкцией с помощью которой происходило
создание и удаление регионов, таким образом регионы организовывались в стек.

Было разработано несколько алгоритмов добавления аннотации регионов в игрушечном
языке основанном на ML, но без возможности динамически влиять на выбор региона
для результата вычислений программы потребляли слишком много памяти по следующим
% 23 
причинам:
\begin{itemize}
\item Когда функция \var{f} возвращала результат в каком-то регионе, то с
  полностью автоматическим управлением она возвращала результат в тот же регион
  каждый раз. А поскольку регион должен существовать пока хоть какой-то из
  результатов функции \var{f} ещё нужен.
\item При рекурсивном вызове функции результат каждого вызова попадал в один и
  тот же регион, независимо от того являлся ли он частью результата или нет.
\end{itemize}

Решением для данной проблемы оказалось введение регионов как параметров функций,
благодаря чему функции стали полиморфными относительно используемых
регионов. Таким образом потребовалось ввести две новые формы:
\begin{itemize}
\item \var{letrec $f[\rho_1,\ldots,\rho_n](x) = e_1$ in $e_2$}
\item \var{$f[\rho_1',\ldots,\rho_n'](x)$} 
\end{itemize}
Первая для создания полиморфных относительно регионов функций, а вторая для
обращения к ним.

Покажем необходимость полиморфных относительно регионов функций на примере
реализации факториала:

\begin{code}
letrec fac(n) =
  if n = 0 then 1
  else n * fac(n-1)
in fac 100
\end{code}\sloppy
Без полиморфных относительно регионов функций соответствующий код с аннотациями
должен выглядеть следующим образом:
% 24 

\begin{code}
letrec fac[r1](n) =
  if n = 0 then 1 at r1
  else (n * fac[r1](n-1)) at r1
in fac[r0] 100
\end{code}
В результате чего в регионе r0 создаётся 100 значений факториалов. С
полиморфными относительно регионов функциями соответствующий код получается
следующим:

\begin{code}
letrec fac[r1](n) =
  if n = 0 then 1 at r1
  else letregion r2
       in (n * fac[r2](n-1)) at r1
       end
in fac[r0] 100
\end{code}
Таким образом, благодаря возможности изменять регион в который складывается
результат, результат каждого рекурсивного вызова будет создан в своём локальном
регионе.

Также была предложена ещё одна оптимизация, которая позволила уменьшить
потребление памяти в случае хвостовой рекурсии. При хвостовом рекурсивном вызове
была добавлена возможность полностью очистить регион с результатом и формировать
результат рекурсивного вызова в том же самом регионе, что и верхнего вызова
функции.

В результате Тофте и Талпин получили систему, которая в программах, хорошо
ложащихся на стек, давала низкое потребление памяти, а в остальных случаях
результаты сильно варьировались. На основе этой работы был создан компилятор
языка Standart ML --- MLKit, который выделял память в автоматически выводимых
регионах. 

Основным направлением дальнейшего изучения системы было создание сборщиков
мусора, которые могли работать в регионах, для обнаружения тех областей памяти,
% 25 
которые в программе больше использованы не будут. Также были предложены
статические методы, которые уменьшали сроки жизни регионов, откладывая создание
региона на максимально длинный срок, а уничтожения производя как можно
раньше~\cite{Aiken:1995}. %TODO: Воду лить сюда.

\subsection{Перенос стека регионов в императивные языки.}

По результатам работы Тофте и Талпина был создан компилятор MLKit, который
показывал высокую скорость работы и позволял предоставлять некоторые гарантии
относительно потребления памяти. В следствие этого было принято множество
попыток переноса регионов в императивные языки программирования. Одним из самых
известных проектов является реализация языка
Cyclone~\cite{Grossman:2002}\cite{Swamy:2006}.

Данный проект реализовал расширение языка C, аналогичное представленному в
работе Тофте и Талпина для ML, с добавлением имени региона в тип указателей, для
того чтобы избежать появления висячих ссылок. Таким образом код 

\begin{code}
int *r1 p;
L:{ int x = 0;
    p = &x;
  }
*p = 42;
\end{code}
при проверке типов обозначается как некорректный, поскольку значение \var{\&x}
имеет тип ``\var{int *rL}'', а \var{p} имеет тип ``\var{int *r1}''.

Кроме проблемы висячих ссылок есть проблема удобства работы. Нередко требуется
возможность работать в одной функции с разными объектами.

Так в качестве примера можно привести следующий код:
% 26 

\begin{code}
void f<r1, r2> (int b, int *r1 p1, int *r2 p2) {
  L:{ int *rL p;
      if (b) p = p1; else p = p2;
      /* ... do something with p ... */
    }
}
\end{code}
при простой проверке типов такой код будет некорректен, поскольку \var{p} не
является ссылкой в регион r1 или r2. И даже выбор одного из этих регионов не
решил бы проблемы, поскольку второе из двух присваиваний оставалось бы
некорректным.

Чтобы позволить использование такого кода в Cyclone было добавлено
автоматическое преобразование типов из указателя в регион \var{rInner}, к
указателю в регион \var{rOuther}, если можно статически доказать, что
\var{rOuther} является внешним регионом (то есть был добавлен на стек регионов
раньше) по отношению к \var{rInner}. Какой из регионов внешний легко определить
для регионов созданных в одной лексической области видимости. Если только один
из регионов был создан в лексической области видимости, то второй регион
считается внешним по отношению к первому. Если же оба региона были переданы в
качестве параметров, то доказать что один из них является внешним по отношению
ко второму невозможно.

При использовании такого приведения типов проблемы висячего указателя не
возникает, поскольку срок жизни указателя из внутренних регионов меньше, чем
срок жизни внешнего региона.

Для данных которые не укладывались в стек регионов в языке Cyclone использовался
глобальный регион, время жизни которого было равно времени работы программы.

Благодаря этому, при простом добавлении аннотаций к программе на \var{C},
потребление памяти ухудшается только в степени необходимой для обеспечения
% 27 
работы стека регионов. Интересно привести результаты полученные авторами при
разработке языка Cyclone относительно скорости работы программ.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{pic/cyclone.jpg}
\caption{Скорость работы Cyclone.}
\label{fig:img5}
\end{figure}

Из рисунка \ref{fig:img5} видно, что несмотря на накладные расходы появляющиеся
из-за введения стека регионов, скорость работы падает в худших случаях больше
чем в два раза, но в среднем на $30\%$, а нередко не падает совсем. При этом 
появляется интерфейс регионов, который позволяет предсказуемо управлять памятью,
а также проводит ряд проверок, для избежания появления висячих ссылок.
%  28 