% -*- mode: LaTeX; mode: auto-fill; mode: flyspell; coding: koi8-r; -*-
% 28 
\chapter{Развитие политики управления памятью на стеке регионов.}

Существует как минимум направления развития идеи управления памятью при помощи
стека регионов:
\begin{itemize}
\item Реализация сборки мусора в регионах.
\item Сокращение срока жизни регионов, а также замена части регионов, на простые
  переменные на стеке, когда общий объём данных известен.
\item Замена стека регионов на стек иных структур данных.
\end{itemize}

Наиболее интересным, и по видимому не изучавшимся ранее, подходом является
замена регионов на иные структуры данных. 

\section{Анализ использования памяти}

Существует всего две линейные структуры данных, которые могут подойти без
существенного усложнения логики системы: стек и очередь.Для выбора между этими
двумя структурами был проведён анализ существующих программ на языке Java, чтобы
выяснить какой подход выглядит более предпочтительным для программистов. Язык
Java был выбран по следующим причинам:
\begin{itemize}
\item Язык содержит сборку мусора и, по этому, в большей части кода программ,
  разработчики не пишут специальный код оптимизирующий работу с памятью.
\item Существует большое число свободного программного кода на Java, который
  можно использовать для анализа.
% 29 
\item Java содержит достаточно мало синтаксического сахара, по сравнению с
  другими языками, такими как C\#, благодаря чему анализатор для неё реализуется
  проще.
\end{itemize}

По коду на Java строилась модель, с семью инструкциями:
\begin{itemize}
\item \var{expr([list of local variables])} \\
  Выражение со списком локальных переменных которые в нём задействованы.
\item \var{create(variable\_name, expr(...)) }\\
  Создание переменной variable\_name и одновременная её инициализация.
\item \var{change(var\_name, expr(...))}\\
  Уничтожение старого значения переменной и установка нового.
\item \var{destroy([list of variable names])}\\
  Уничтожение старого значения всех переменных указанных в списке.
\item \var{block([Instructions in block])}\\
  Блок кода содержащий набор инструкций.
\item \var{if(expr(...), [Then commands list], [Else commands list])}\\
  Инструкция ветвления, которая в соответствии со значением условия выбирает
  какой из блоков выполнять.
\item \var{cycle(Before\_Expression, Condition, [Body commands list], Post\_Expr)}\\
  Блок выполняющийся в цикле. ``Before\_Expression'' выполняется единожды перед
  входом в цикл, ``Condition'' выполняется на каждом шаге работы цикла, а
  ``Post\_Expr'' предназначен для уничтожения объектов созданных в
  ``Before\_Expression''. В этой конструкции ``Before\_Expression'' является не
  пустым, например, для специальной формы ``for (init expression; condition;
  expression)'', существующей в Java.
\end{itemize}

Для этого были проведены следующие преобразования:
\begin{itemize}
\item Из исходного кода были выделены только функции. Определения классов,
  прототипов объектов и импорта каких-либо пакетов был проигнорирован.
% 30 
\item Выражения и вызовы методов, а также изменение переменных не из локальной
  области видимости, были заменены на инструкцию ``\var{expr(...)}''.
\item Объявление локальных переменных было заменено на инструкцию
  ``\var{create(...)}''.
\item Присваивание локальной переменной нового значения заменялось на инструкцию
  ``\var{change(...)}''.
\item Циклы и ветвления заменялись на инструкции ``\var{cycle(...)}'' и
  ``\var{if(...)}'' соответственно.
\item Простые блоки кода заменялись на инструкцию ``\var{block(...)}''.
\item Для каждого аргумента функции добавлялась инструкция
  ``\var{create(variable, expr([]))}'' в начале кода функции.
\end{itemize}

В полученный код добавлялись инструкции ``\var{destroy([List of local
  variables])}'' после последнего использования переменной. Если это
использование было в теле цикла, то инструкция \var{destroy} вызывалась после
выхода из цикла. Если оно было внутри блока ``\var{if(expr(...), Then, Else)}'',
то инструкция добавлялась и в блок \var{Then} и в блок \var{Else}. Если же
последнее использование переменной \var{var\_name} было в инструкциях
\var{change}, \var{create} или \var{expr} на том же уровне вложенности, что и
% 31 
инструкция ``\var{create(var\_name, ...)}, то инструкция \var{destroy}
добавлялась сразу после найденной инструкции.

После выполнения предложенных преобразований получался код в предложенной
модели. Так если применить преобразования к следующему коду:

\begin{code}
private IType[] findInterfaces(IType type)
{   Collection<IType> interfaces = new ArrayList<IType>();
    IIFinder[] finders = getImplementorFinders();
    
    for (int i = 0; i < finders.length; i++) {
	Collection<IType> types = 
           finders[i].findIn(type, this.Monitor);
	if (types != null) {
	    interfaces.addAll(types);
	}
    }    
    return interfaces.toArray(new IType[interfaces.size()]);
}
\end{code}
преобразовывался в следующий набор инструкций:

\begin{code}
func(findInterfaces,
  [ create(type,expr([])),
    create(interfaces,expr([])),
    create(finders,expr([])),
    cycle(create(i,expr([])),
          expr([i,finders,i]),
      [ create(types,expr([finders,i,type])),
        if(expr([types]),
          [ expr([interfaces,types]),
            destroy([types])
          ],
          [ destroy([types])
          ]
        )
      ],
      destroy([i,type,finders])
    ),
    expr([interfaces,interfaces]),
    destroy([interfaces])
  ]
)
\end{code}
% 32 
Это достаточно простая модель и она не отражает связи между объектами в
программе на Java, но она позволяет оценить практики построения кода.

Далее, для кода построенного на данной модели было проведено извлечение всех
возможных путей выполнения. Для этих целей код с инструкцией ``\var{if(Cond,
  Then, Else)}'' заменялся на два пути: на одном инструкция \var{if} заменялась
на ``\var{block([Cond | Then])}'', на втором инструкция \var{if} заменялась на
``\var{block([Cond | Else])}''. Аналогично инструкция ``\var{cycle(Before, Cond,
Body, After)}'' заменялась на код ``\var{block([Before, Cond, Body, ... Cond,
Body, After])}''. Для определённости считалось что каждый цикл выполняется
десять раз, поскольку увеличение или уменьшение числа циклов не могло серьёзно
повлиять на исследуемый вопрос.

В качестве примера рассмотрим следующий код в котором есть одно ветвление и
отсутствуют циклы:

\begin{code}
func(function,
  [ create(types,expr([])),
    create(i,expr([types])),
    if(expr([types]),
      [ expr([types,i]),
        destroy([types])
      ],
      [ destroy([types])
      ]
    ),
    expr([i]),
    destroy([i])
  ]
)
\end{code}
% 33 
В нём существуют два пути исполнения:

\begin{code}
paths([
  [ create(types,expr([])),
    create(i,expr([types])),
    block([
      expr([types]),
      expr([types,i]),
      destroy([types])
    ]),
    expr([i]),
    destroy([i])
  ],

  [ create(types,expr([])),
    create(i,expr([types])),
    block([
      expr([types]),
      destroy([types])
    ]),
    expr([i]),
    destroy([i])
  ]
]) 
\end{code}

После извлечения всех возможных путей исполнения из программы инструкции
выполнялись на двух выбранных моделях:
\begin{itemize}
\item Переменные располагаются на стеке стеков.
  \begin{itemize}
  \item При входе в каждый блок для его локальных переменных создавался новый
    стек.
  \item При выходе из блока со стека стеков снимался верхний стек со всеми
    созданными в нём переменными.
  \item При выполнении команды ``\var{create(var, ...)}'' создавалась переменная
    \var{var} на вершине верхнего стека данных.
% 34 
  \item При выполнении команды ``\var{change(var, ...)}'' находился стек в
    котором была создана переменная с именем \var{var}, переменная помечалась
    как удалённая. Далее с вершины этого стека данных удалялись все переменные
    помеченные как удалённые, после чего на вершине этого стека создавалась
    новая переменная \var{var}.
  \item При выполнении команды ``\var{destroy([list of variables])}'' для каждой
    переменной из списка обнаруживался стек в котором переменная была создана,
    переменная помечалась как удалённая, а с вершины стека удалялись все
    переменные помеченные как удалённые.
  \end{itemize}
\item Переменные располагаются на стеке очередей.
  \begin{itemize}
  \item При входе в каждый блок для его локальных переменных создавалась новая
    очередь.
  \item При выходе из блока со стека очередей снималась верхняя очередь со всеми
    созданными в нём переменными.
  \item При выполнении команды ``\var{create(var, ...)}'' создавалась переменная
    \var{var} в конце верхней очереди данных.
  \item При выполнении команды ``\var{change(var, ...)}'' находилась очередь в
    которой была создана переменная с именем \var{var}, переменная помечалась
    как удалённая. Далее с начала этой очереди данных удалялись все переменные
    помеченные как удалённые, после чего в конце этой очереди создавалась новая
    переменная \var{var}.
  \item При выполнении команды ``\var{destroy([list of variables])}'' для каждой
    переменной из списка обнаруживалась очередь в которой переменная была
    создана, переменная помечалась как удалённая, а с начала очереди удалялись
    все переменные помеченные как удалённые.
  \end{itemize}
\end{itemize}
% 35 

Во время выполнения после каждой инструкции \var(expr), \var(create),
\var(change) и \var(destroy), сохранялось количество переменных, как живых, так
и помеченных как удалённые, располагающихся в памяти в данный момент. Например
для виденного выше варианта пути

\begin{code}
[ create(types,expr([])),
  create(i,expr([types])),
  block([
    expr([types]),
    destroy([types])
  ]),
  expr([i]),
  destroy([i])
]
\end{code}

В модели использующей стек стеков результатом будет результатом будет
$[1,2,2,2,2,0]$, а в модели со стеком очередей $[1,2,2,1,1,0]$.
% TODO: заменить на картинки из гнуплотика

После получения результатов потребления памяти для каждого в каждой модели
вычислялось среднее потребление памяти и значения сравнивались для двух моделей.

Данная проверка была проведена на 50 файлах выбранных случайным образом из
состава исходных кодов программ eclipse и jruby. В результате были получены
следующие данные:
\begin{itemize}
\item Было выделено 22490 различных путей по всем функциям всех исходных кодов.
% 36  
\item На 848 путях стек стеков в среднем потреблял меньше памяти, чем стек
  очередей.
\item На 2265 путях среднее потребление памяти в обеих моделях было одинаковым.
\item На 19377 путях стек очередей потреблял меньше памяти, чем стек стеков.
\end{itemize}

\section{Синтаксическое представление стека очередей.}

Для синтаксического представления стека очередей, параллельно с блочной
структурой должна существовать структура перекрывающихся блоков, как на рисунке
\ref{fig:img6}.

\begin{figure}[H]
\centering
\includegraphics{pic/queue.eps}
\caption{Перекрывающиеся блоки}
\label{fig:img6}
\end{figure}

Легко заметить, что если queue и end не помечены отдельными символами, то язык
перекрывающихся блоков эквивалентен языку сбалансированных скобок и отличается
лишь семантикой. В то же время если начала и концы блоков помечены произвольными
% 37 
символами, то язык не является контекстно свободным, поскольку при разборе
случая ``\verb=begin_queue(a) S end_queue(a) Q='' для того, чтобы
распознать Q необходимо иметь список всех ``\verb=begin_queue(X)=''
обнаруженных в S и проверить наличие и порядок соответствующих
``\verb=end_queue='' в Q.

Если же допустить лишь конечное число меток, то есть ограничить размер очереди
конечным числом, то легко можно построить грамматику, если вынести порядок уже
найденных меток в имена не терминалов. Построим возможную грамматику разбирающую
три возможные метки для обозначения начала и конца очереди. Пусть эти метки
выглядят как пары `(~...~)', `[~...~]', '\{~...~\}'. В таком случае грамматика
может выглядеть так:

\begin{code}
S -> '(' NC | '[' NS | '{' NF | nil

NC -> '[' NCS | '{' NCF | ')' S
NF -> '(' NFC | '[' NFS | ']' S
NS -> '(' NSC | '{' NSF | ']' S

NCF -> '[' NCFS | ')' NF
NCS -> '{' NCSF | ')' NS

NSF -> '(' NSFC | ']' NF
NSC -> '{' NSCF | ']' NC

NFS -> '(' NFSC | '}' NS
NFC -> '[' NFCS | '}' NC

NCSF -> ')' NSF  
NCFS -> ')' NFS
NSCF -> ']' NCF
NSFC -> ']' NFC
NFCS -> '}' NCS
NFSC -> '}' NSC
\end{code}

где \var{nil} это пустое слово. Аналогичная грамматика для большего числа меток
% 38 
будет содержать $\sum\limits_{k=0}^{n} A_n^k$ не терминальных символов, где
$A_n^k$ это количество размещений $k$ различных меток из $n$ возможных.

Практическое использование таких грамматик не представляется возможным,
поскольку даже для небольшого ограничения в десять различных меток потребуется
9864101 не терминальных символов.
% 39 
